#!/usr/bin/env python3

import argparse, base64, configparser, getpass, json, os, pykeepass
import nanopy as npy
from nanopy.rpc import RPC


class bcolours:
    _ok1 = "\033[34m"
    _ok2 = "\033[35m"
    _ok3 = "\033[32m"
    _warn1 = "\033[33m"
    _warn2 = "\033[31m"
    _end = "\033[0m"
    _bold = "\033[1m"

    def plain(self, s, prefix="", suffix=""):
        print(prefix + s + suffix)

    def ok1(self, s, prefix="", suffix=""):
        print(prefix + self._ok1 + s + self._end + suffix)

    def ok2(self, s, prefix="", suffix=""):
        print(prefix + self._ok2 + s + self._end + suffix)

    def ok3(self, s, prefix="", suffix=""):
        print(prefix + self._ok3 + s + self._end + suffix)

    def warn1(self, s, prefix="", suffix=""):
        print(prefix + self._warn1 + s + self._end + suffix)

    def warn2(self, s, prefix="", suffix=""):
        print(prefix + self._warn2 + s + self._end + suffix)

    def bold(self, s, prefix="", suffix=""):
        print(prefix + self._bold + s + self._end + suffix)

    def boldstr(self, s):
        return self._bold + s + self._end

    def amt(self, label, amount, colour=plain):
        colour("{:>40}".format(amount), label + " : ", " " + std_unit)

    def status(self, label, msg, colour=plain):
        colour(self, msg, label + " : ")


bc = bcolours()


def get_no_value_options(section):
    try:
        options = config.options(section)
    except:
        return None
    try:
        options.remove("tor")
    except:
        pass
    try:
        options.remove("rpc")
    except:
        pass
    try:
        options.remove("offline")
    except:
        pass
    try:
        options.remove("account")
    except:
        pass
    try:
        options.remove("frontier")
    except:
        pass
    try:
        options.remove("balance")
    except:
        pass
    try:
        options.remove("representative")
    except:
        pass
    return options


def nag_rep(nb):
    try:
        w = int(rpc.account_info(nb["representative"], weight=True)["weight"])
        if w * 100 / available_supply > 2 and not args.rep:
            bc.warn1("\nYour representative has too much voting weight.")
            if (input("Change rep?(" + bc.boldstr("y") + "/n): ") or "y") == "y":
                args.rep = input("Rep : ")
    except:
        pass


def generate_block(sk, pk, account):
    nb = npy.state_block()
    nb["account"] = account
    bc.status("Acc", nb["account"])

    info = {"error": "Account not found"}
    rb = {}
    state_found = False
    for state in states:
        if config[state]["account"] == nb["account"]:
            state_found = True
            break

    while True:
        if online:
            info = rpc.account_info(nb["account"], representative=True)
            rb = rpc.accounts_pending([nb["account"]])["blocks"]
            if rb:
                rb = rb[nb["account"]]
        elif state_found:
            try:
                info["frontier"] = config[state]["frontier"]
                info["balance"] = config[state]["balance"]
                info["representative"] = config[state]["representative"]
            except:
                pass
            rb = get_no_value_options(state)
        try:
            nb["previous"] = info["frontier"]
            nb["balance"] = info["balance"]
            nb["representative"] = info["representative"]
            bc.amt("Bal", npy.from_raw(nb["balance"]), bc.ok1)
            bc.status("Rep", nb["representative"])

            if online:
                nag_rep(nb)

            if args.rep:
                assert npy.validate_account_number(args.rep)
                nb["representative"] = args.rep

            if (not args.send) and (not args.rep):
                if state_found and online:
                    config[state]["frontier"] = info["frontier"]
                    config[state]["balance"] = info["balance"]
                    config[state]["representative"] = info["representative"]
                    with open(config_file, "w") as f:
                        config.write(f)
                if not rb:
                    break
                if (
                    input("\nReceive pending blocks?(" + bc.boldstr("y") + "/n): ")
                    or "y"
                ) != "y":
                    break

        except KeyError:
            if not rb:
                bc.warn2(info)
                break
            else:
                args.send = None
                nb["balance"] = "0"
                bc.amt("Bal", npy.from_raw(nb["balance"]), bc.ok1)
                nb["representative"] = input("Rep : ")

        if args.send:
            nb["link"] = npy.account_key(args.send)
            bc.status("To ", npy.account_get(nb["link"]))
            if args.empty:
                bc.amt("Amt", npy.from_raw(nb["balance"]), bc.warn2)
                nb["balance"] = "0"
            else:
                while True:
                    amount = int(npy.to_raw(input("Amt : ")))
                    if amount <= int(nb["balance"]):
                        nb["balance"] = str(int(nb["balance"]) - amount)
                        break
                    bc.warn2("Amount must be less than or equal to balance.")
            bc.amt("Bal", npy.from_raw(nb["balance"]), bc.warn1)

        elif rb:
            nb["link"] = rb[0]
            if online:
                r_block = rpc.blocks_info(rb)["blocks"][nb["link"]]
                bc.status("From", r_block["block_account"])
                amount = r_block["amount"]
                nb["balance"] = str(int(nb["balance"]) + int(amount))
            else:
                amount = config[state][rb[0]]
                nb["balance"] = str(int(nb["balance"]) + int(amount))
            bc.amt("Amt", npy.from_raw(amount), bc.ok3)
            bc.amt("Bal", npy.from_raw(nb["balance"]), bc.ok3)

        if args.send or args.rep or rb:
            current_difficulty = None
            if args.network == "nano":
                current_difficulty = "fffffff800000000"  # 8x
                if rb:
                    current_difficulty = "fffffe0000000000"  # 1/8x

            args.send = None
            args.rep = None

            work_hash = (
                nb["previous"]
                if (nb["previous"] != "0" * 64)
                else npy.account_key(nb["account"])
            )

            nb["work"] = npy.work_generate(work_hash, difficulty=current_difficulty)
            nb["signature"] = npy.sign(sk, block=nb, pk=pk)

            print("\n" + json.dumps(nb))

            if (
                input(
                    "\n"
                    + ("Broadcast block" if online else "Update state")
                    + "?(y/"
                    + bc.boldstr("n")
                    + "): "
                )
                or "n"
            ) == "y":
                if args.demo:
                    bc.warn1("demo mode")
                else:
                    if online:
                        ack = rpc.process(json.dumps(nb))
                        try:
                            bc.ok3(ack["hash"])
                        except:
                            bc.warn2(ack)
                            state_found = False
                    if state_found:
                        config[state]["frontier"] = npy.block_hash(nb)
                        config[state]["balance"] = nb["balance"]
                        config[state]["representative"] = nb["representative"]
                        if rb:
                            try:
                                config.remove_option(state, rb[0])
                            except:
                                pass
                        with open(config_file, "w") as f:
                            config.write(f)
                        bc.ok3("saved new state to", config_file)


parser = argparse.ArgumentParser()

subparsers = parser.add_subparsers()
parser_open = subparsers.add_parser("open", help="Unlock *.kdbx file")
parser_open.add_argument("f", metavar="FILE", type=str, help="*.kdbx file.")
parser_open.add_argument("k", metavar="KEY", type=str, help="key to open/create.")
parser_open.add_argument(
    "-g",
    "--group",
    default="",
    type=str,
    help="Group in which to open key from. (Default=root)",
)
parser_open.add_argument(
    "-i",
    "--index",
    default=0,
    type=int,
    help="Index of the account unlocked from the key. (Default=0)",
)
parser_open.add_argument(
    "-r", "--rep", metavar="ADDRESS", help="Change representative to ADDRESS."
)
parser_open.add_argument("--offline", action="store_true", help="Run in offline mode.")

open_group = parser_open.add_mutually_exclusive_group()
open_group.add_argument("-s", "--send", metavar="ADDRESS", help="Send NANO to ADDRESS.")
open_group.add_argument(
    "-e", "--empty", metavar="ADDRESS", help="Send all the funds to ADDRESS."
)
open_group.add_argument(
    "-a",
    "--audit",
    action="store_true",
    help="Check state of all accounts from index 0 to INDEX.",
)

open_group.add_argument(
    "-n",
    "--new",
    action="store_true",
    help="Generate a new key and save.",
)
parser.add_argument(
    "-a",
    "--audit-file",
    metavar="FILE",
    type=argparse.FileType("rb"),
    help="Check state of all the accounts in FILE.",
)
parser.add_argument(
    "-b", "--broadcast", action="store_true", help="Broadcast a block in JSON format."
)
parser.add_argument(
    "-n",
    "--network",
    default="nano",
    choices=["nano", "beta", "banano"],
    type=str,
    help="Choose the network to interact with.",
)
parser.add_argument(
    "-t", "--tor", action="store_true", help="Connect to the RPC node via tor."
)
parser.add_argument("-d", "--demo", action="store_true", help="Run in demo mode.")

args = parser.parse_args()

if args.network == "beta":
    npy.account_prefix = "xrb_"
    rpc_url = "http://localhost:55000"
    std_unit = "β"
    available_supply = 340272367920938463463374607431768151531
elif args.network in ["banano", "ban"]:
    args.network = "banano"
    npy.account_prefix = "ban_"
    npy.work_difficulty = "fffffe0000000000"
    npy.standard_exponent = 29
    rpc_url = "http://localhost:7072"
    std_unit = "BAN"
    available_supply = 340280899595938463463374589668199818054
else:
    args.network = "nano"
    rpc_url = "http://localhost:7076"
    std_unit = "Ӿ"
    available_supply = 133248061999106578273467128948453216035

home_npy = os.path.expanduser("~") + "/.config/nanopy/"
os.makedirs(home_npy, mode=0o700, exist_ok=True)
os.chmod(home_npy, 0o700)

config_file = home_npy + args.network + ".conf"
os.chmod(config_file, 0o600)
config = configparser.ConfigParser(allow_no_value=True)
config.read(config_file)

states = config.sections()
try:
    states.remove("Accounts")
except:
    pass

online = not config["DEFAULT"].getboolean("offline")
if online:
    try:
        online = not args.offline
    except:
        online = True

if online:
    try:
        iploc = RPC(
            url="http://ipinfo.io/json",
            tor=(args.tor or config["DEFAULT"].getboolean("tor", fallback=args.tor)),
        )._get()
        try:
            bc.warn1(iploc["city"] + " " + iploc["country"])
        except:
            print(iploc)
    except:
        pass
    rpc = RPC(
        url=config["DEFAULT"].get("rpc", fallback=rpc_url),
        tor=(args.tor or config["DEFAULT"].getboolean("tor", fallback=args.tor)),
    )
else:
    bc.warn1("Running in offline mode.")

try:
    unlock = args.f and args.k
    if args.demo:
        bc.warn1("Running in demo mode.")
    if args.empty:
        args.send = args.empty
except:
    unlock = False

accounts = []

if unlock:
    os.chmod(args.f, 0o600)
    kp = pykeepass.PyKeePass(args.f, password=getpass.getpass())
    group = kp.find_groups(name=args.group, first=True) if args.group else kp.root_group

    if args.new:
        seed = os.urandom(32)
        _, _, account0 = npy.deterministic_key(seed.hex(), 0)
        bc.status(args.k, account0)
        if args.demo:
            bc.warn1("demo mode")
        else:
            kp.add_entry(group, args.k, account0, base64.b85encode(seed).decode())
            kp.save()

    else:
        entry = kp.find_entries(title=args.k, group=group, recursive=False, first=True)
        seed = base64.b85decode(entry.password).hex()
        _, _, account0 = npy.deterministic_key(seed, 0)
        assert entry.username == account0

        if args.audit:
            for i in range(args.index + 1):
                _, _, account_i = npy.deterministic_key(seed, i)
                accounts.append(account_i)

        else:
            generate_block(*npy.deterministic_key(seed, args.index))

elif args.broadcast and online:
    if args.demo:
        bc.warn1("demo mode")
    else:
        ack = rpc.process(input("Enter JSON block to broadcast: "))
        try:
            bc.ok3(ack["hash"])
        except:
            bc.warn2(ack)

elif args.audit_file:
    accounts = [line.rstrip(b"\n").decode() for line in args.audit_file]

else:
    accounts = get_no_value_options("Accounts")

if accounts and online:
    info = rpc.accounts_balances(accounts)
    for account in accounts:
        bc.status("Acc", account)
        try:
            bc.amt("Bal", npy.from_raw(info["balances"][account]["balance"]), bc.ok1)
            if int(info["balances"][account]["pending"]):
                bc.ok3("Pending block(s)")
        except:
            bc.warn2(info)
        print("")

if online:
    rpc.disconnect()

ticker = RPC(
    url="https://api.kraken.com/0/public/Ticker?pair=nanoxbt,nanousd,nanoeur"
)._get()
try:
    print(
        ticker["result"]["NANOXBT"]["c"][0],
        "₿\t",
        ticker["result"]["NANOUSD"]["c"][0],
        "$\t",
        ticker["result"]["NANOEUR"]["c"][0],
        "€",
    )
except:
    print(ticker)
